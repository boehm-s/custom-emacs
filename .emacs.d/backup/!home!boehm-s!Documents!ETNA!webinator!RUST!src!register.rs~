extern crate iron;
extern crate staticfile;
extern crate router;
extern crate mount;
extern crate iron_postgres_middleware as pg_middleware;
extern crate ws;
extern crate bodyparser;
extern crate serde_json;
extern crate pwhash;

use mount::Mount;
use router::Router;
use staticfile::Static;

use pwhash::bcrypt;

use std::thread;
use std::path::Path;
use std::io::Read;

use iron::prelude::*;
use iron::status;
use iron::mime::Mime;
//use iron::{Iron, Request, Response, IronResult, status};

use ws::listen;

use pg_middleware::{PostgresMiddleware, PostgresReqExt};

use serde_json::Value;
//_____________________________________________________________________________________________________


pub fn register(req: &mut Request) -> IronResult<Response> {
    let mut str_body = String::new();
    let mut res:Value = serde_json::from_str("{}").unwrap();
    let con = req.db_conn();
    let json_body = req.get::<bodyparser::Json>();

    match json_body {
        Ok(Some(json_body)) => res = json_body,
        Ok(None) => println!("No body"),
        Err(err) => println!("Error: {:?}", err)
    }

    let obj = res.as_object().unwrap();
    let email = serde_json::to_string(obj.get("email").unwrap()).unwrap();
    let username = serde_json::to_string(obj.get("username").unwrap()).unwrap();
    let password = serde_json::to_string(obj.get("password").unwrap()).unwrap();
    let hex = bcrypt::hash(&password.to_string()).unwrap();

    con.execute("INSERT INTO users (email, username, password) VALUES ($1, $2, $3);", &[&email, &username, &hex]).unwrap();

    println!("HEY : {:?}", obj.get("email").unwrap());
    // read the POST body
    req.body.read_to_string(&mut str_body).unwrap();

    let out = serde_json::to_string(&res).unwrap();
    let content_type = "application/json".parse::<Mime>().unwrap();
    Ok(Response::with((status::Ok, content_type, out)))
}
